/** This file was generated by the Dustbin::Games LUAWrapGenerator (w) 2020 by Christian Keimel **/

#include <_generated/lua/lua_tables.h>
#include <_generated/lua/lua_enums.h>
#include <_generated/lua/CLuaSceneObject.h>
#include <_generated/lua/CLuaCameraObject.h>
#include <_generated/lua/CLuaSingleton_dialog.h>
#include <_generated/lua/CLuaScript_dialog.h>
#include <lua/CLuaTypeHelpers.h>


// ***************************************
// LUA Binding for class "CLuaSceneObject"
// ***************************************
// Replace a texture of the scene node by a texture containing some text
static int CLuaSceneObject_settexttexture(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 5) { luaL_error(a_pState, "Not enough arguments for function \"settexttexture\". 4 arguments required."); return 0; }

  SColor l_background;
  if (lua_gettop(a_pState) >= 9) {
    l_background.loadFromStack(a_pState); lua_pop(a_pState, 1);
  }
  else {
    l_background = dustbin::lua::colorStringToLua("FFFFFF");
  }
  SColor l_textcolor;
  if (lua_gettop(a_pState) >= 8) {
    l_textcolor.loadFromStack(a_pState); lua_pop(a_pState, 1);
  }
  else {
    l_textcolor = dustbin::lua::colorStringToLua("000000");
  }
  bool l_center;
  if (lua_gettop(a_pState) >= 7) {
    if (!lua_isboolean(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"center\" is not a boolean."); return  0; }
    l_center = lua_toboolean(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);
  }
  else {
    l_center = false;
  }
  bool l_alpha;
  if (lua_gettop(a_pState) >= 6) {
    if (!lua_isboolean(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"alpha\" is not a boolean."); return  0; }
    l_alpha = lua_toboolean(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);
  }
  else {
    l_alpha = false;
  }
  int l_height;
  if (!lua_isinteger(a_pState, lua_gettop(a_pState)) && !lua_isnumber(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"height\" is not a number, integer expected."); return  0; }
  l_height = (int)lua_tointeger(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);
  int l_width;
  if (!lua_isinteger(a_pState, lua_gettop(a_pState)) && !lua_isnumber(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"width\" is not a number, integer expected."); return  0; }
  l_width = (int)lua_tointeger(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);
  std::string l_text;
  if (!lua_isstring(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"text\" is not a string."); return  0; }
  l_text = lua_tostring(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);
  int l_material;
  if (!lua_isinteger(a_pState, lua_gettop(a_pState)) && !lua_isnumber(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"material\" is not a number, integer expected."); return  0; }
  l_material = (int)lua_tointeger(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);

  try {
    l_pObject->settexttexture(l_material, l_text, l_width, l_height, l_alpha, l_center, l_textcolor, l_background);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:settexttexture failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Replace a texture of the scene node by an image
static int CLuaSceneObject_setimagetexture(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 3) { luaL_error(a_pState, "Not enough arguments for function \"setimagetexture\". 2 arguments required."); return 0; }

  std::string l_image;
  if (!lua_isstring(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"image\" is not a string."); return  0; }
  l_image = lua_tostring(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);
  int l_material;
  if (!lua_isinteger(a_pState, lua_gettop(a_pState)) && !lua_isnumber(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"material\" is not a number, integer expected."); return  0; }
  l_material = (int)lua_tointeger(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);

  try {
    l_pObject->setimagetexture(l_material, l_image);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:setimagetexture failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Set the scale of the scene object
static int CLuaSceneObject_setscale(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"setscale\". 1 argument required."); return 0; }

  SVector3d l_scale;
  l_scale.loadFromStack(a_pState); lua_pop(a_pState, 1);

  try {
    l_pObject->setscale(l_scale);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:setscale failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Initialize the object with a child of the passed scene object
static int CLuaSceneObject_initchild(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 3) { luaL_error(a_pState, "Not enough arguments for function \"initchild\". 2 arguments required."); return 0; }

  std::string l_child;
  if (!lua_isstring(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"child\" is not a string."); return  0; }
  l_child = lua_tostring(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);
  CLuaSceneObject *l_object;
  if (!lua_isuserdata(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"object\" is not an object."); return  0; }
  l_object = reinterpret_cast<CLuaSceneObject *>(lua_touserdata(a_pState, lua_gettop(a_pState))); lua_pop(a_pState, 1);

  try {
    l_pObject->initchild(l_object, l_child);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:initchild failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Initialize the object by cloning the passed node
static int CLuaSceneObject_initclone(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"initclone\". 1 argument required."); return 0; }

  CLuaSceneObject *l_object;
  if (!lua_isuserdata(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"object\" is not an object."); return  0; }
  l_object = reinterpret_cast<CLuaSceneObject *>(lua_touserdata(a_pState, lua_gettop(a_pState))); lua_pop(a_pState, 1);

  try {
    l_pObject->initclone(l_object);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:initclone failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Find out whether or not the object is currently visible
static int CLuaSceneObject_isvisible(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);

  try {
    bool l_Ret = l_pObject->isvisible();
    lua_pushboolean(a_pState, l_Ret);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:isvisible failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 1;
}

// Initialize the object with a node from the scene
static int CLuaSceneObject_initialize(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"initialize\". 1 argument required."); return 0; }

  std::string l_nodename;
  if (!lua_isstring(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"nodename\" is not a string."); return  0; }
  l_nodename = lua_tostring(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);

  try {
    l_pObject->initialize(l_nodename);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:initialize failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Set the rotation of the scene object in Euler angles
static int CLuaSceneObject_setrotation(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"setrotation\". 1 argument required."); return 0; }

  SVector3d l_rotation;
  l_rotation.loadFromStack(a_pState); lua_pop(a_pState, 1);

  try {
    l_pObject->setrotation(l_rotation);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:setrotation failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Set the position of the scene object
static int CLuaSceneObject_setposition(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"setposition\". 1 argument required."); return 0; }

  SVector3d l_position;
  l_position.loadFromStack(a_pState); lua_pop(a_pState, 1);

  try {
    l_pObject->setposition(l_position);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:setposition failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Set the visibility of the scene node
static int CLuaSceneObject_setvisible(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"setvisible\". 1 argument required."); return 0; }

  bool l_visible;
  if (!lua_isboolean(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"visible\" is not a boolean."); return  0; }
  l_visible = lua_toboolean(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);

  try {
    l_pObject->setvisible(l_visible);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:setvisible failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Retrieve the position of the scene node
static int CLuaSceneObject_getposition(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaSceneObject *l_pObject = (CLuaSceneObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);

  try {
    SVector3d l_Ret = l_pObject->getposition();
    l_Ret.pushToStack(a_pState);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSceneObject:getposition failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 1;
}

static luaL_Reg SCLuaSceneObjectMethods[] = {
  { "settexttexture", CLuaSceneObject_settexttexture },
  { "setimagetexture", CLuaSceneObject_setimagetexture },
  { "setscale", CLuaSceneObject_setscale },
  { "initchild", CLuaSceneObject_initchild },
  { "initclone", CLuaSceneObject_initclone },
  { "isvisible", CLuaSceneObject_isvisible },
  { "initialize", CLuaSceneObject_initialize },
  { "setrotation", CLuaSceneObject_setrotation },
  { "setposition", CLuaSceneObject_setposition },
  { "setvisible", CLuaSceneObject_setvisible },
  { "getposition", CLuaSceneObject_getposition },
  { NULL, NULL }
};

void CLuaSceneObject::registerMethods(lua_State *a_pState) {
  LuaWrap::register_class<CLuaSceneObject>(a_pState, "LuaSceneObject", SCLuaSceneObjectMethods, NULL, LuaWrap::InternalLua::default_new<CLuaSceneObject>, LuaWrap::InternalLua::default_gc<CLuaSceneObject>);
}

void *CLuaSceneObject::getObjectFromLuaStack(const std::string &a_sIdentifier) {
  lua_getglobal(m_pState, a_sIdentifier.c_str());
  if (lua_islightuserdata(m_pState, lua_gettop(m_pState))) {
    void *l_pObject = reinterpret_cast<CLuaSceneObject *>(lua_touserdata(m_pState, lua_gettop(m_pState)));
    lua_pop(m_pState, 1);
    return l_pObject;
  }
  else return nullptr;
}


// ****************************************
// LUA Binding for class "CLuaCameraObject"
// ****************************************
// Adds a new camera to the scene
static int CLuaCameraObject_initialize(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaCameraObject *l_pObject = (CLuaCameraObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);

  try {
    l_pObject->initialize();
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaCameraObject:initialize failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Set the position of the camera
static int CLuaCameraObject_setposition(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaCameraObject *l_pObject = (CLuaCameraObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"setposition\". 1 argument required."); return 0; }

  SVector3d l_position;
  l_position.loadFromStack(a_pState); lua_pop(a_pState, 1);

  try {
    l_pObject->setposition(l_position);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaCameraObject:setposition failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Make this camera the scene manager's active camera
static int CLuaCameraObject_activate(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaCameraObject *l_pObject = (CLuaCameraObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);

  try {
    l_pObject->activate();
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaCameraObject:activate failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Set the target of the camera
static int CLuaCameraObject_settarget(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaCameraObject *l_pObject = (CLuaCameraObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"settarget\". 1 argument required."); return 0; }

  SVector3d l_target;
  l_target.loadFromStack(a_pState); lua_pop(a_pState, 1);

  try {
    l_pObject->settarget(l_target);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaCameraObject:settarget failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

// Set the up-vector of the camera
static int CLuaCameraObject_setupvector(lua_State *a_pState) {
  if (!lua_isuserdata(a_pState, 1)) {
    luaL_error(a_pState, "Invalid receiver.");
    return 0;
  }

  CLuaCameraObject *l_pObject = (CLuaCameraObject *)lua_touserdata(a_pState, 1);
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"setupvector\". 1 argument required."); return 0; }

  SVector3d l_upvector;
  l_upvector.loadFromStack(a_pState); lua_pop(a_pState, 1);

  try {
    l_pObject->setupvector(l_upvector);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaCameraObject:setupvector failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

static luaL_Reg SCLuaCameraObjectMethods[] = {
  { "initialize", CLuaCameraObject_initialize },
  { "setposition", CLuaCameraObject_setposition },
  { "activate", CLuaCameraObject_activate },
  { "settarget", CLuaCameraObject_settarget },
  { "setupvector", CLuaCameraObject_setupvector },
  { NULL, NULL }
};

void CLuaCameraObject::registerMethods(lua_State *a_pState) {
  LuaWrap::register_class<CLuaCameraObject>(a_pState, "LuaCameraObject", SCLuaCameraObjectMethods, NULL, LuaWrap::InternalLua::default_new<CLuaCameraObject>, LuaWrap::InternalLua::default_gc<CLuaCameraObject>);
}

void *CLuaCameraObject::getObjectFromLuaStack(const std::string &a_sIdentifier) {
  lua_getglobal(m_pState, a_sIdentifier.c_str());
  if (lua_islightuserdata(m_pState, lua_gettop(m_pState))) {
    void *l_pObject = reinterpret_cast<CLuaCameraObject *>(lua_touserdata(m_pState, lua_gettop(m_pState)));
    lua_pop(m_pState, 1);
    return l_pObject;
  }
  else return nullptr;
}


// ********************************************
// LUA Binding for class "CLuaSingleton_dialog"
// ********************************************
// Load an Irrlicht scene file
static int CLuaSingleton_dialog_loadscene(lua_State *a_pState) {
  CLuaSingleton_dialog *l_pObject = nullptr;
  lua_getglobal(a_pState, "dialog3d_cinstance");
  if (lua_islightuserdata(a_pState, lua_gettop(a_pState))) {
    l_pObject = reinterpret_cast<CLuaSingleton_dialog *>(lua_touserdata(a_pState, lua_gettop(a_pState)));
    lua_pop(a_pState, 1);
  }
  else throw std::string("\"CLuaSingleton_dialog\" instance not found on lua heap.");
  l_pObject->setLuaState(a_pState);
  int l_iArgC = lua_gettop(a_pState);
  if (l_iArgC < 2) { luaL_error(a_pState, "Not enough arguments for function \"loadscene\". 1 argument required."); return 0; }

  std::string l_filename;
  if (!lua_isstring(a_pState, lua_gettop(a_pState))) { luaL_error(a_pState, "\"filename\" is not a string."); return  0; }
  l_filename = lua_tostring(a_pState, lua_gettop(a_pState)); lua_pop(a_pState, 1);

  try {
    l_pObject->loadscene(l_filename);
  }
  catch (std::string &s) {
    luaL_error(a_pState, (std::string("Function CLuaSingleton_dialog:loadscene failed: \"") + std::string(s + std::string("\""))).c_str());
  }
  return 0;
}

static luaL_Reg SCLuaSingleton_dialogMethods[] = {
  { "loadscene", CLuaSingleton_dialog_loadscene },
  { NULL, NULL }
};

void *CLuaSingleton_dialog::getObjectFromLuaStack(const std::string &a_sIdentifier) {
  lua_getglobal(m_pState, a_sIdentifier.c_str());
  if (lua_islightuserdata(m_pState, lua_gettop(m_pState))) {
    void *l_pObject = reinterpret_cast<CLuaSingleton_dialog *>(lua_touserdata(m_pState, lua_gettop(m_pState)));
    lua_pop(m_pState, 1);
    return l_pObject;
  }
  else return nullptr;
}

CLuaSingleton_dialog::CLuaSingleton_dialog(lua_State *a_pState) {
  m_pState = a_pState;
  LuaWrap::register_singleton(m_pState, "dialog", SCLuaSingleton_dialogMethods);

  lua_pushlightuserdata(m_pState, (void *)this);
  lua_setglobal(m_pState, "dialog3d_cinstance");
}

CLuaSingleton_dialog::~CLuaSingleton_dialog() {
}


// *****************************************
// LUA Binding for class "CLuaScript_dialog"
// *****************************************
// This function is called when the script starts, should be used for initialization and such
void CLuaScript_dialog::initialize() {
  lua_getglobal(m_pState, "initialize");
  if (!lua_isnil(m_pState, -1)) {
    if (lua_pcall(m_pState, 0, 0, 0) != 0) {
      std::string l_sMessage = std::string("ERROR: function \"initialize\" failed: \"") + std::string(lua_tostring(m_pState, -1)) + std::string("\"");
      throw std::string(l_sMessage.c_str());
    }
  }
  else lua_pop(m_pState, 1);

}

void *CLuaScript_dialog::getObjectFromLuaStack(const std::string &a_sIdentifier) {
  lua_getglobal(m_pState, a_sIdentifier.c_str());
  if (lua_islightuserdata(m_pState, lua_gettop(m_pState))) {
    void *l_pObject = reinterpret_cast<CLuaScript_dialog *>(lua_touserdata(m_pState, lua_gettop(m_pState)));
    lua_pop(m_pState, 1);
    return l_pObject;
  }
  else return nullptr;
}

CLuaScript_dialog::CLuaScript_dialog(const std::string &a_sScript) {
  // Commands defined in the "prefix" section of the JSON class definition


  // Create LUA State
  m_pState = luaL_newstate();
  luaL_openlibs(m_pState);

  // Store a reference of this script on the LUA stack
  lua_pushlightuserdata(m_pState, (void *)this);
  lua_setglobal(m_pState, "script_cinstance");

  // Store the instance again with the identifier defined in the JSON
  lua_pushlightuserdata(m_pState, (void *)this);
  lua_setglobal(m_pState, "dialog_cinstance");

  // Export LUA classes
  CLuaSceneObject::registerMethods(m_pState);
  CLuaCameraObject::registerMethods(m_pState);

  // Export LUA enumerations

  // Create and register singletons
  m_LuaSgt_dialog = new CLuaSingleton_dialog(m_pState);
  int l_iResult = luaL_dostring(m_pState, a_sScript.c_str());

  if (l_iResult != 0) {
    if (!lua_isnil(m_pState, -1)) {
      std::string l_sMsg = "LUA Error: ";
      l_sMsg += lua_tostring(m_pState, -1);
      throw std::string(l_sMsg.c_str());
    }
    else {
      lua_close(m_pState);
      m_pState = nullptr;
      std::string l_sMsg = "Error ";
      l_sMsg += std::to_string(l_iResult);
      l_sMsg += " on \"CLuaScript_dialog\" execution.";
      throw std::string(l_sMsg.c_str());
    }
  }
}

CLuaScript_dialog::~CLuaScript_dialog() {
  if (m_pState != nullptr)
    lua_close(m_pState);
}

